---
layout: single
title:  "(summation)백,프론트 기초 개념 요약"
categories: summation
tags: 백엔드, 프론트엔드, React, js, basic
---

백,프론트 기초 개념 요약

---

학원에서 수업 들으면서 정리한 것을 복습하려고 블로그에 쓰는 거라서 난잡할 수 있습니다.

---

객체의 비구조 할당은 키 값이 지정 돼 있어서 변수명을 지정 못함

배열의 비구조 할당은 직접 변수의 이름을 지정가능, 2개를 지정하면 배열의 순서대로 2개만 비구조 할당함.

[a, b, r...] => rest : 나머지를 변수에 다 들고온다.

---

long 자료형을 쓸 때 뒤에 l을 씀으로써 long자료형에 넣을 수 있게 형변환 하는 것이다.(long 자료형에 int자료형의 값을 넣는다면)

박싱, 언박싱 : 제네릭안의 자료형은(Integer)은 객체 
레퍼자료형을 일반자료형으로 바꾸는 것과 그 반대를 박싱, 언박싱이라고 함
Integer n = 10; <= 박싱

업, 다운 캐스팅

---

js는 값의 자료형에 따라 자료형이 정해진다. 
=> var = a <= 그냥 이렇게 쓰면 undifinded가 뜸(값을 넣지 않아서 자료형이 정해지지 않음)
그래서 js에서는 매개변수의 자료형을 적지 않음

---

매개변수 뒤의 : 은 리턴 타입이다. 

```sql
A({ name, age } : User) : Promise <void>
=> User에서 비구조 할당한다. 리턴타입이 Promise이고 결과값은 void라서 없다.
```

---

useState()의 리턴값은 배열이다.

---

메소드 오버로딩: 매개변수 자료형이 다르면 이름이 같은 메소드 정의 가능(매개변수 자료형타입, 갯수, 순서 등등이 달라야 함)
js에서는 안됨 : js랑 java랑 컴파일하는 방식이 다르다. (호이스팅도 있고) : 똑같은 이름의 함수가 있으면 밑의 걸로 덮어씌운다.(파이썬도 함수의 오버로딩이 없음)
-> 오버로딩처럼 쓰고싶을 때 : 조건을 걸어서 만약 c가 undefinde이면 저 메소드를 실행 시키고 아니면 다른 메소드를 실행 시켜라 라고 오버로딩같이 쓸 수 있게 할 수 있다.

오버라이딩: 부모 메소드를 재정의 하는 것

---

react의 테그들은 돔 객체들이다.

props(속성: 테그안의 type="text" 라면 type이 속성, text는 속성 값 / 객체안에서의 키 값도 속성이라고 함) : 키 벨류 형식으로 넣어주면 쓸 수 있음, props라는 객체
자동완성 때문에 props 비구조 할당 함 - 컴포넌트의 특징, 컴포넌트라서 리턴은 무조건 jsx

---

재렌더링 : 함수의 재호출
1. props가 바뀌었을 때(얘도 props가 바뀐 부분 부터 재렌더링 됨)(1)
2. 부모가 재렌더링 되면 자식도 재렌더링 된다.
3. 상태가 바뀌면 부모는 재랜더링되지 않고 그 부분 부터 재렌더링 됨(3)


index.js(상위) == #root


(3)버추얼 돔 : 상태가 변하면 변한 위치부터 렌더링이 되고 버추얼 돔은 그 전부분 부터 변한 부분까지 카피하고 새로 실행될 얘까지 만듦
상태변화감지 -> 버추얼돔 만듦 -> 실제 돔과 비교 후 비교된 부분에서 다른 부분만 교체한다
버추얼돔 덕분에 부분 렌더링이 가능하다.

(1) props가 변하면 재랜더링 -> 하지만 자식의 propsr는 변함 없음 -> 함수의 재호출(재렌더링)만 일어난다(화면상 변화는 일어나지 않는다.) => 돔이 변하지는 않는다. 돔과 jsx는 별개
버추얼돔 생성은 하지만 다른 부분이 없기 때문에 교체하지 않는다.
정리: props의 값이 10에서 20으로 바뀌어도 html코드가 바뀌지 않았기 때문에 (눈에 보여줘야 될 코드가 달라짐) 재렌더링 돼서 버추얼돔이 만들어져도 리얼돔과 다른 부분 비교해서 교체하지 않는다.

상태 재렌더링 예시에서 ) 재렌더링 돼야 변수에 새로 대입할 수 있다.

onClick에 () => handleClick() <- 정의(매개변수에 넣을 수도 있음)를 넣음

set함수 자체가 비동기이다.

then실행 : promise가 실행됐을 때 resolve가 실행됐을 때 실행됨

재렌더링때문에 set함수 다음에 값을 넣으면 걔는 리턴에 안나오게 됨

---

useEffect: 비동기, 마운트(장착,완제품 = 화면에 보이는 것)됐을 때 실행 됨

특징: 1. 리턴이 되고 실행된다.
        1. 무조건 처음 한 번 실행된다.
	    
디펜던시는 꼭 상태가 아니어도 되고 그냥 값이면 됨

useEffect의 디펜던시: 
1. 빈 배열일 때 - 처음 한 번만 실행되고 끝
2. 디펜던시가 아예 없을 때 - 매 번 재렌더링 될 때 마다 실행
3. 값을 넣으면 - 그 값이 바뀔 때 마다 실행

---

mount: 컴포넌트가 완성되고 나서 장착되어지는 시점(타이어와 휠이 장착되고 다같이 장착)
unmount: 마운트의 역순(조립의 역순, 휠다음에 타이어 분리함)
사용 예) 화면이 사라질때 변화를 주고싶을 때 사용됨 

```sql
<Test t={num} t2={test3} />
=> 리턴에 컴포넌트(함수를 테그처럼 사용함)가 있으면 컴포넌트(함수)가 호출돼서 실행된다.
```












